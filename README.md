# 002-stg

## TODO

- [x] シーンの切り替え調査 →SceneManager
- [x] セーブ調査 →PlayerPrefs
- [x] タイトルシーン作成
  - [x] 戦闘シーンへの移行
- [ ] 戦闘シーン作成
  - [x] Player、Enemy、Shot を文字と図形で表示
  - [x] Player 表示
  - [x] Player 移動（仮想 Pad）
  - [x] Enemy 配置
  - [x] Enemy 移動
  - [x] 視界回転
  - [x] マップ
    - [x] 調査 →Camera、Render Texture、Layer
    - [x] 表示
    - [x] Order in Layer
    - [x] Tilemap
    - [x] マップ処理（敵は Player より広い範囲を移動できる）
  - [x] ロックオンフレーム表示
  - [x] Player 体力設定
    - [x] Player HP バー表示（分数も）
  - [x] Enemy 体力設定
  - [x] Player の攻撃
    - [x] 自動射撃
    - [x] 当たり判定
    - [x] トリガーボタンで制御
    - [x] 狙い切り換え
      - [x] 近
      - [x] 弱
      - [x] 強
    - [x] 武器切り換えボタンで切り換え
  - [x] キーボード、ゲームパッドに対応
    - [x] InputSystem [Unity の新入力システム・Input System を使おう – Unity for Pro](https://forpro.unity3d.jp/unity_pro_tips/2021/05/20/1957/)
    - [x] Joystick Pack の DynamicJoystick 配置
    - [x] 仮想ボタン配置
  - [x] Unity のホットリロード対応
  - [ ] null チェックを無くしたい
  - [ ] 戦闘終了演出
    - [ ] タイトルシーンへ移行
  - [ ] Enemy の攻撃
    - [ ] 自動射撃
    - [ ] 当たり判定
    - [ ] 体当たり
  - [ ] Enemy 破壊
    - [ ] アイテム生成（HP 回復、バリア、資源（金））
    - [ ] アイテム取得
- [ ] 複数ステージ
  - [ ] ステージデータ形式調査
  - [ ] ステージ生成
  - [ ] ステージ選択シーン追加
    - [ ] 戦闘シーンへ移行
    - [ ] 戦闘シーンクリア後ステージ選択シーンへ
  - [ ] 最終ステージ終了後エンディング
- [ ] セーブ
- [ ] 作りこみ
  - [ ] 武器
    - [ ] ミサイル
    - [ ] ライフル
    - [ ] ショットガン
  - [ ] Enemy 破壊演出
  - [ ] 複数種の敵
  - [ ] Enemy Hive
    - [ ] 自動ポップ
  - [ ] Player、Enemy、Shot 画像作成、差し替え
  - [ ] BGM 入手、設定
  - [ ] SE 入手、設定

## MEMO

### Unity でホットリロードする方法

#### 要点

フィールドの型やプロパティの宣言を見て、フィールドの値や参照などがホットリロードで失われるか判断する。

プロパティが失われる場合はバッキングフィールドや set アクセサーを使用する。

フィールドの型が UnityEngine.Object の派生でないときは、その型の定義に [System.Serializable](https://docs.unity3d.com/ja/2021.3/ScriptReference/Serializable.html) 属性をつける。  
ただし、フィールドの型がインターフェースや抽象クラスであるときはインターフェイスを実装するクラスや具象クラスにつける。

System.Serializable 属性をつけたクラスのインスタンスを参照するフィールドには [UnityEngine.SerializeReference](https://docs.unity3d.com/2021.3/Documentation/ScriptReference/SerializeReference.html) 属性をつける。

System.Serializable 属性をつけられないクラスのインスタンスにはプロパティ経由でアクセスする。
null になったときに get アクセサーの中で再作成する。

#### プロパティのシリアライズ

[Unity - Manual: Script serialization](https://docs.unity3d.com/2021.3/Documentation/Manual/script-Serialization.html) で `Unity serializes properties with autogenerated fields during hot reloading only.` と書かれているが、get アクセサーのみの自動実装プロパティは失われる。  
set アクセサーをつけるとフィールドと同じようにシリアライズされる。  
get アクセサーのみであっても、シリアライズされるためのバッキングフィールドを定義するとホットリロードに対応できる。

```csharp
    public string Name1 { get; } // 失われる。
    public string Name2 { get; set; } // 失われない。
    public string Name3 => name; // 失われない（バッキングフィールドの name がシリアライズされるから）。
    private string name;
```

#### private フィールド

[Unity - Manual: Script serialization](https://docs.unity3d.com/2021.3/Documentation/Manual/script-Serialization.html) で `Unlike other cases of serialization, Unity serializes private fields by default when reloading, even if they don’t have the ‘SerializeField’ attribute.` と書かれているように、SerializeField 属性をつけなくてもホットリロード中 private フィールドはシリアライズされる。

#### UnityEngine.Object から派生していないクラスのインスタンス

自作の UnityEngine.Object から派生していないクラスのインスタンスをホットリロードに対応させるには、そのクラスの定義に System.Serializable 属性をつける。  
インターフェイスや抽象クラスはインスタンス化しないので、それらには System.Serializable 属性をつけず、インターフェイスを実装するクラスや具象クラスに属性をつける。

System.Serializable 属性をつけたクラスのインスタンスを参照するフィールド（やプロパティ）には UnityEngine.SerializeReference 属性をつけた方が良い。  
UnityEngine.Object から派生していないクラスのインスタンスを参照し、かつその属性がついていないフィールドは、フィールドの定義に使われている型の値としてシリアライズされてしまう。  
つまりインターフェイスや抽象クラスの型が定義に使われている属性のついていないフィールドはホットリロードに失敗して null になる。

#### List\<T>

[List\<T>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0) のフィールドは [Unity - Scripting API: SerializeReference](https://docs.unity3d.com/2021.3/Documentation/ScriptReference/SerializeReference.html) で `For array and List<T> fields, the SerializeReference attribute applies to the elements of the array or list and not to the array or list object itself.` とあるように、型 T によって UnityEngine.SerializeReference 属性をつけるかつけないか判断すれば良い。

#### System.Serializable でないクラスのインスタンス

System.Serializable をつけられないクラス（Input System の Input Actions が自動生成するクラスなど）のインスタンスは失われるので再作成する。  
フィールドのインスタンスにプロパティ経由でアクセスするようにして、フィールドのインスタンスが失われていたら get アクセサー内で再作成すると NullReferenceException を避けやすい。

```csharp
    private InputActions? inputActions;
    public InputActions InputActions
    {
        get
        {
            if (inputActions == null)
            {
                inputActions = new InputActions();
                inputActions.Enable();
            }
            return inputActions;
        }
    }
```

#### ホットリロードとシリアライズについての参考情報

- [Unity - Manual: Script serialization](https://docs.unity3d.com/2021.3/Documentation/Manual/script-Serialization.html)
- [Unity - Scripting API: SerializeReference](https://docs.unity3d.com/2021.3/Documentation/ScriptReference/SerializeReference.html)

### フィールドとプロパティとメソッドの使用の優先順位

インスタンスに状態を持たせたい場合は、まず private フィールドを使う。  
private フィールドはそれが定義されているクラスのコンストラクタやインスタンスメソッド以外で変更しないようにする。

他のクラスのインスタンスから状態にアクセスさせたいときは、プロパティが使えないか考える。  
ただしプロパティ内ではキャッシュのためのフィールド以外を変更しないようにする。

フィールドを変更している箇所を把握しやすいときは private プロパティを使わなくても良い。

状態を変更したい場合は public メソッドを使う。

public メソッドの内容を分割したい場合は private メソッドを使う。

```csharp
    // フィールドとプロパティとメソッドの使用を検討する順に並べた。
    private T field;
    public T Property => field;
    public T Property { get; set; }
    // フィールドの変更箇所が分かりやすいときは private プロパティを使わなくても良い。
    // private T Property => field;
    // private T Property { get; set; }
    public T Method() {};
    private T method() {};
```
